package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"zamcv2bff/graph/generated"
	"zamcv2bff/graph/model"
	"zamcv2bff/internal/auth"

)

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	authUser, ok := user.(*auth.User)
	if !ok {
		return nil, fmt.Errorf("invalid user context")
	}

	// Query user from database
	var dbUser model.User
	err := r.DB.QueryRow(`
		SELECT id, email, name, avatar, created_at, updated_at 
		FROM users WHERE id = $1
	`, authUser.ID).Scan(
		&dbUser.ID, &dbUser.Email, &dbUser.Name, &dbUser.Avatar,
		&dbUser.CreatedAt, &dbUser.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		// Create user if doesn't exist
		dbUser = model.User{
			ID:        authUser.ID,
			Email:     authUser.Email,
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		}

		_, err = r.DB.Exec(`
			INSERT INTO users (id, email, created_at, updated_at)
			VALUES ($1, $2, $3, $4)
		`, dbUser.ID, dbUser.Email, dbUser.CreatedAt, dbUser.UpdatedAt)

		if err != nil {
			return nil, fmt.Errorf("failed to create user: %w", err)
		}
	} else if err != nil {
		return nil, fmt.Errorf("failed to query user: %w", err)
	}

	return &dbUser, nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) ([]*model.Project, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	authUser, ok := user.(*auth.User)
	if !ok {
		return nil, fmt.Errorf("invalid user context")
	}

	rows, err := r.DB.Query(`
		SELECT id, name, description, status, owner_id, created_at, updated_at
		FROM projects WHERE owner_id = $1
		ORDER BY created_at DESC
	`, authUser.ID)

	if err != nil {
		return nil, fmt.Errorf("failed to query projects: %w", err)
	}
	defer rows.Close()

	var projects []*model.Project
	for rows.Next() {
		var project model.Project
		err := rows.Scan(
			&project.ID, &project.Name, &project.Description, &project.Status,
			&project.OwnerID, &project.CreatedAt, &project.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan project: %w", err)
		}
		projects = append(projects, &project)
	}

	return projects, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	authUser, ok := user.(*auth.User)
	if !ok {
		return nil, fmt.Errorf("invalid user context")
	}

	var project model.Project
	err := r.DB.QueryRow(`
		SELECT id, name, description, status, owner_id, created_at, updated_at
		FROM projects WHERE id = $1 AND owner_id = $2
	`, id, authUser.ID).Scan(
		&project.ID, &project.Name, &project.Description, &project.Status,
		&project.OwnerID, &project.CreatedAt, &project.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("project not found")
	} else if err != nil {
		return nil, fmt.Errorf("failed to query project: %w", err)
	}

	return &project, nil
}

// Board is the resolver for the board field.
func (r *queryResolver) Board(ctx context.Context, id string) (*model.Board, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	var board model.Board
	err := r.DB.QueryRow(`
		SELECT b.id, b.name, b.description, b.project_id, b.created_at, b.updated_at
		FROM boards b
		JOIN projects p ON b.project_id = p.id
		WHERE b.id = $1
	`, id).Scan(
		&board.ID, &board.Name, &board.Description, &board.ProjectID,
		&board.CreatedAt, &board.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("board not found")
	} else if err != nil {
		return nil, fmt.Errorf("failed to query board: %w", err)
	}

	return &board, nil
}

// ChatMessages is the resolver for the chatMessages field.
func (r *queryResolver) ChatMessages(ctx context.Context, boardID string, limit *int, offset *int) ([]*model.ChatMessage, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	limitVal := 50
	if limit != nil {
		limitVal = *limit
	}

	offsetVal := 0
	if offset != nil {
		offsetVal = *offset
	}

	rows, err := r.DB.Query(`
		SELECT id, content, user_id, board_id, created_at
		FROM chat_messages 
		WHERE board_id = $1
		ORDER BY created_at DESC
		LIMIT $2 OFFSET $3
	`, boardID, limitVal, offsetVal)

	if err != nil {
		return nil, fmt.Errorf("failed to query chat messages: %w", err)
	}
	defer rows.Close()

	var messages []*model.ChatMessage
	for rows.Next() {
		var message model.ChatMessage
		err := rows.Scan(
			&message.ID, &message.Content, &message.UserID,
			&message.BoardID, &message.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan chat message: %w", err)
		}
		messages = append(messages, &message)
	}

	return messages, nil
}

// ApproveAsset is the resolver for the approveAsset field.
func (r *mutationResolver) ApproveAsset(ctx context.Context, assetID string) (*model.Asset, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	authUser, ok := user.(*auth.User)
	if !ok {
		return nil, fmt.Errorf("invalid user context")
	}

	now := time.Now()
	_, err := r.DB.Exec(`
		UPDATE assets 
		SET status = $1, approved_by = $2, approved_at = $3, updated_at = $4
		WHERE id = $5
	`, model.AssetStatusApproved, authUser.ID, now, now, assetID)

	if err != nil {
		return nil, fmt.Errorf("failed to approve asset: %w", err)
	}

	// Get updated asset
	var asset model.Asset
	err = r.DB.QueryRow(`
		SELECT id, name, type, url, status, board_id, approved_by, approved_at, created_at, updated_at
		FROM assets WHERE id = $1
	`, assetID).Scan(
		&asset.ID, &asset.Name, &asset.Type, &asset.URL, &asset.Status,
		&asset.BoardID, &asset.ApprovedBy, &asset.ApprovedAt,
		&asset.CreatedAt, &asset.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to query updated asset: %w", err)
	}

	// Publish board update
	err = r.NatsConn.PublishBoardUpdate(asset.BoardID, &asset)
	if err != nil {
		log.Printf("Failed to publish board update: %v", err)
	}

	return &asset, nil
}

// Chat is the resolver for the chat field.
func (r *mutationResolver) Chat(ctx context.Context, boardID string, content string) (*model.ChatMessage, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	authUser, ok := user.(*auth.User)
	if !ok {
		return nil, fmt.Errorf("invalid user context")
	}

	message := model.ChatMessage{
		ID:        uuid.New().String(),
		Content:   content,
		UserID:    authUser.ID,
		BoardID:   boardID,
		CreatedAt: time.Now(),
	}

	_, err := r.DB.Exec(`
		INSERT INTO chat_messages (id, content, user_id, board_id, created_at)
		VALUES ($1, $2, $3, $4, $5)
	`, message.ID, message.Content, message.UserID, message.BoardID, message.CreatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to create chat message: %w", err)
	}

	// Publish board update
	err = r.NatsConn.PublishBoardUpdate(boardID, &message)
	if err != nil {
		log.Printf("Failed to publish board update: %v", err)
	}

	return &message, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.CreateProjectInput) (*model.Project, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	authUser, ok := user.(*auth.User)
	if !ok {
		return nil, fmt.Errorf("invalid user context")
	}

	project := model.Project{
		ID:          uuid.New().String(),
		Name:        input.Name,
		Description: input.Description,
		Status:      model.ProjectStatusActive,
		OwnerID:     authUser.ID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	_, err := r.DB.Exec(`
		INSERT INTO projects (id, name, description, status, owner_id, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
	`, project.ID, project.Name, project.Description, project.Status,
		project.OwnerID, project.CreatedAt, project.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to create project: %w", err)
	}

	return &project, nil
}

// CreateBoard is the resolver for the createBoard field.
func (r *mutationResolver) CreateBoard(ctx context.Context, input model.CreateBoardInput) (*model.Board, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	board := model.Board{
		ID:          uuid.New().String(),
		Name:        input.Name,
		Description: input.Description,
		ProjectID:   input.ProjectID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	_, err := r.DB.Exec(`
		INSERT INTO boards (id, name, description, project_id, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6)
	`, board.ID, board.Name, board.Description, board.ProjectID,
		board.CreatedAt, board.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to create board: %w", err)
	}

	return &board, nil
}

// UploadAsset is the resolver for the uploadAsset field.
func (r *mutationResolver) UploadAsset(ctx context.Context, input model.UploadAssetInput) (*model.Asset, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	asset := model.Asset{
		ID:        uuid.New().String(),
		Name:      input.Name,
		Type:      input.Type,
		URL:       &input.URL,
		Status:    model.AssetStatusPending,
		BoardID:   input.BoardID,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	_, err := r.DB.Exec(`
		INSERT INTO assets (id, name, type, url, status, board_id, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
	`, asset.ID, asset.Name, asset.Type, asset.URL, asset.Status,
		asset.BoardID, asset.CreatedAt, asset.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to create asset: %w", err)
	}

	// Publish board update
	err = r.NatsConn.PublishBoardUpdate(input.BoardID, &asset)
	if err != nil {
		log.Printf("Failed to publish board update: %v", err)
	}

	return &asset, nil
}

// BoardUpdated is the resolver for the boardUpdated field.
func (r *subscriptionResolver) BoardUpdated(ctx context.Context, boardID string) (<-chan *model.BoardUpdate, error) {
	user := ctx.Value("user")
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	ch := make(chan *model.BoardUpdate, 1)

	// Subscribe to NATS updates
	sub, err := r.NatsConn.SubscribeBoardUpdates(boardID, func(data []byte) {
		var update model.BoardUpdate

		// Try to unmarshal as Asset first
		var asset model.Asset
		if err := json.Unmarshal(data, &asset); err == nil {
			update = &asset
		} else {
			// Try to unmarshal as ChatMessage
			var message model.ChatMessage
			if err := json.Unmarshal(data, &message); err == nil {
				update = &message
			} else {
				log.Printf("Failed to unmarshal board update: %v", err)
				return
			}
		}

		select {
		case ch <- &update:
		case <-ctx.Done():
			return
		}
	})

	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to board updates: %w", err)
	}

	// Clean up subscription when context is done
	go func() {
		<-ctx.Done()
		sub.Unsubscribe()
		close(ch)
	}()

	return ch, nil
}

// Owner is the resolver for the owner field.
func (r *projectResolver) Owner(ctx context.Context, obj *model.Project) (*model.User, error) {
	var user model.User
	err := r.DB.QueryRow(`
		SELECT id, email, name, avatar, created_at, updated_at
		FROM users WHERE id = $1
	`, obj.OwnerID).Scan(
		&user.ID, &user.Email, &user.Name, &user.Avatar,
		&user.CreatedAt, &user.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to query user: %w", err)
	}

	return &user, nil
}

// Boards is the resolver for the boards field.
func (r *projectResolver) Boards(ctx context.Context, obj *model.Project) ([]*model.Board, error) {
	rows, err := r.DB.Query(`
		SELECT id, name, description, project_id, created_at, updated_at
		FROM boards WHERE project_id = $1
		ORDER BY created_at DESC
	`, obj.ID)

	if err != nil {
		return nil, fmt.Errorf("failed to query boards: %w", err)
	}
	defer rows.Close()

	var boards []*model.Board
	for rows.Next() {
		var board model.Board
		err := rows.Scan(
			&board.ID, &board.Name, &board.Description, &board.ProjectID,
			&board.CreatedAt, &board.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan board: %w", err)
		}
		boards = append(boards, &board)
	}

	return boards, nil
}

// Project is the resolver for the project field.
func (r *boardResolver) Project(ctx context.Context, obj *model.Board) (*model.Project, error) {
	var project model.Project
	err := r.DB.QueryRow(`
		SELECT id, name, description, status, owner_id, created_at, updated_at
		FROM projects WHERE id = $1
	`, obj.ProjectID).Scan(
		&project.ID, &project.Name, &project.Description, &project.Status,
		&project.OwnerID, &project.CreatedAt, &project.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to query project: %w", err)
	}

	return &project, nil
}

// Assets is the resolver for the assets field.
func (r *boardResolver) Assets(ctx context.Context, obj *model.Board) ([]*model.Asset, error) {
	rows, err := r.DB.Query(`
		SELECT id, name, type, url, status, board_id, approved_by, approved_at, created_at, updated_at
		FROM assets WHERE board_id = $1
		ORDER BY created_at DESC
	`, obj.ID)

	if err != nil {
		return nil, fmt.Errorf("failed to query assets: %w", err)
	}
	defer rows.Close()

	var assets []*model.Asset
	for rows.Next() {
		var asset model.Asset
		err := rows.Scan(
			&asset.ID, &asset.Name, &asset.Type, &asset.URL, &asset.Status,
			&asset.BoardID, &asset.ApprovedBy, &asset.ApprovedAt,
			&asset.CreatedAt, &asset.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan asset: %w", err)
		}
		assets = append(assets, &asset)
	}

	return assets, nil
}

// Board is the resolver for the board field.
func (r *assetResolver) Board(ctx context.Context, obj *model.Asset) (*model.Board, error) {
	var board model.Board
	err := r.DB.QueryRow(`
		SELECT id, name, description, project_id, created_at, updated_at
		FROM boards WHERE id = $1
	`, obj.BoardID).Scan(
		&board.ID, &board.Name, &board.Description, &board.ProjectID,
		&board.CreatedAt, &board.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to query board: %w", err)
	}

	return &board, nil
}

// ApprovedBy is the resolver for the approvedBy field.
func (r *assetResolver) ApprovedBy(ctx context.Context, obj *model.Asset) (*model.User, error) {
	if obj.ApprovedBy == nil {
		return nil, nil
	}

	var user model.User
	err := r.DB.QueryRow(`
		SELECT id, email, name, avatar, created_at, updated_at
		FROM users WHERE id = $1
	`, *obj.ApprovedBy).Scan(
		&user.ID, &user.Email, &user.Name, &user.Avatar,
		&user.CreatedAt, &user.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to query user: %w", err)
	}

	return &user, nil
}

// User is the resolver for the user field.
func (r *chatMessageResolver) User(ctx context.Context, obj *model.ChatMessage) (*model.User, error) {
	var user model.User
	err := r.DB.QueryRow(`
		SELECT id, email, name, avatar, created_at, updated_at
		FROM users WHERE id = $1
	`, obj.UserID).Scan(
		&user.ID, &user.Email, &user.Name, &user.Avatar,
		&user.CreatedAt, &user.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to query user: %w", err)
	}

	return &user, nil
}

// Board is the resolver for the board field.
func (r *chatMessageResolver) Board(ctx context.Context, obj *model.ChatMessage) (*model.Board, error) {
	var board model.Board
	err := r.DB.QueryRow(`
		SELECT id, name, description, project_id, created_at, updated_at
		FROM boards WHERE id = $1
	`, obj.BoardID).Scan(
		&board.ID, &board.Name, &board.Description, &board.ProjectID,
		&board.CreatedAt, &board.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to query board: %w", err)
	}

	return &board, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// Project returns generated.ProjectResolver implementation.
func (r *Resolver) Project() generated.ProjectResolver { return &projectResolver{r} }

// Board returns generated.BoardResolver implementation.
func (r *Resolver) Board() generated.BoardResolver { return &boardResolver{r} }

// Asset returns generated.AssetResolver implementation.
func (r *Resolver) Asset() generated.AssetResolver { return &assetResolver{r} }

// ChatMessage returns generated.ChatMessageResolver implementation.
func (r *Resolver) ChatMessage() generated.ChatMessageResolver { return &chatMessageResolver{r} }

type queryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type boardResolver struct{ *Resolver }
type assetResolver struct{ *Resolver }
type chatMessageResolver struct{ *Resolver } 